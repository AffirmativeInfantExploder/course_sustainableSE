---
author: Luc Dop, Sabina Grădinariu, Nawmi Nujhat, Vincent van Vliet
title: "Energy Consumption Comparison: Python 3.14 vs Python 3.11"
image: "../img/p1_measuring_software/gX_template/cover.png"
date: 24/02/2025
summary: |-
   This study explores the energy consumption differences between Python 3.14 and Python 3.11, testing the claim that Python 3.14 has a 30% speed improvement over previous versions. We run the same computational tasks in controlled environments and measure power usage, execution time, and overall efficiency. 
   Our setup includes automation for both Linux and MacOS with system parameters that can be tweaked according to the need, ensuring replicability. Future work will involve the  --with-tail-call-interp flag once it is working.
--- 
## Introduction
As programmers, we use programming languages daily, often forgetting how much impact the chosen language, and sometimes even its version, can have on energy consumption and implicitly on the environment ( [check]( https://arxiv.org/html/2410.05460v1) ). Python is known to be one of the most used languages, but also, according to previous studies such as [Ranking programming languages by energy efficiency](https://www.sciencedirect.com/science/article/abs/pii/S0167642321000022?via%3Dihub), it is amongst the least green (energy efficient) due to its interpreted execution and dynamic typing.

With the introduction of Python version 3.14, the documentation states that it utilizes a new type of interpreter that should provide significantly better performance. To be precise, preliminary numbers indicate anywhere from '-3% to 30% faster' [Python](https://docs.python.org/3.14/whatsnew/3.14.html) code. With this performance improvement kept in mind, we have decided to investigate this claim to see how the performance increase impacts the energy consumption.

We started by analyzing Python 3.14 default configuration, without any additional optimizations. The documentation also mentions an experimental feature called the tail call interpreter, which is expected to enhance performance further when enabled. [Tail call-interp](https://docs.python.org/3.14/using/configure.html#cmdoption-with-tail-call-interp) should not be confused with [tail call optimization](https://en.wikipedia.org/wiki/Tail_call) of Python functions. 

However, this feature is opt-in, requires specific compiler versions (Clang 19+ on x86-64 and AArch64 architectures), and remains unavailable in the default build. Despite our efforts, we could not enable it, because it is not working yet. Therefore, our current study concentrates on benchmarking Python 3.14’s default interpreter against Python 3.11 to assess energy efficiency under highly demanding tasks.

## Methodology 
To this end, the idea is to use the prerelease version of the Python 3.14 interpreter and compare the energy consumption for the same code snippet for both the new interpreter as well as an older Python interpreter (3.11.9). This should allow us to see whether the supposed faster speeds of the new interpreter impact energy consumption. 
To assess the energy consumption we used [EnergiBridge](https://github.com/tdurieux/EnergiBridge) as suggested in the [lectures](https://luiscruz.github.io/course_sustainableSE/2025/).

### Code Snippet Selection 
To make sure that the comparison is a meaningful one, we used computationally intensive code that will stress the CPU. We create multiple snippets that can be seen on [GitLab](https://github.com/vincentvvliet/sse-project-group-24). 

### Hardware 
For the experiment on Windows we used an ASUS Vivobook with the following specifications:
- Windows 11 home.
- 12th Gen Intel(R) Core(TM) i7-12650H 2.30 GHz processor
- 16 GB Ram.
- Brightness level of 30
- Resolution of 1920 x 1200.
- Wifi turned off.

### Experiment Procedure 
Before the experiment begins we create a list of 30 instances of python 3.11 and 30 instances of python 3.14. We then shuffle this list to determine the order in which they get run. To warm up the hardware we begin the experiment by performing a CPU intensive task for 5 minutes. In our case that means repeatedly calculating the squares of the numbers in the range [0, 10^6) for the duration of the 5 minutes. After this is done, we go through the previously created list, and pick a version of python to run. We then create two sub processes, one for Energibridge to measure the energy consumption, and one to run a benchmark script on the picked version of Python. The benchmark script generates two 300 x 300 matrices, which then get multiplied. After this is done and energy consumption has been saved we let the process wait for 1 minute. This is to prevent tail energy consumption from the previous run from influencing the measurement in the next run.
### Replication

## Results
For the Windows experiment we analyze the 'PACKAGE_ENERGY (J)' value generated by Energibridge. This is a cumulative value, where we specifically look at the difference between the value at the start of a run and at the end of a run. To try and normalize the data we perform z-score outlier removal.

Before analyzing our results we first check to see if they have a normal distribution. Performing the Shapiro-Wilk test we see that Python 3.11 has a p-value of 0.091, while Python 3.14 has a p-value of 0.007. This means that while Python 3.11 can be considered normal, Python 3.14 cannot. For this reason we will look at the median difference between the two sets of results. To graph the difference in median energy consumption between Python 3.11 and Python 3.14 we create a bar plot that uses half of the interquartile range (IQR) as error bars.
![Median_energy_comparison.png](..%2Fimg%2Fp1_measuring_software%2Fg24_python_3.14%2Fmedian_energy_comparison.png)

Looking at the graph, we see that Python 3.11 has a median energy consumption of 20.01, while Python 3.14 has a slightly lower mean of 19.05. This is a difference of 0.96 J. While this is not a large difference, it could suggest Python 3.14 is slightly more energy efficient. The error bars seem to overlap significantly in both versions however, which could indicate that the difference in median energy consumption between Python 3.11 and 3.14 could be due to normal fluctuations.

To get more insight into the distribution spread and shape of the data we created a Violin+box plot. 
![Box+violinplot.png](..%2Fimg%2Fp1_measuring_software%2Fg24_python_3.14%2Fenergy_comparison.png)

Looking at the plot, we see that the results of both versions of python have a relatively wide distribution at the center, showing that for both versions the values are mostly concentrated around 18-20 J. Python 3.14 seems to have broader spread than Python 3.11, with lower outliers extending to ~15 J and higher ones beyond 26 J. This greater number of outliers is consistent with the p-value we found earlier. To check for statistical significance between the two datasets we use the Mann-Whitney U test, from which we determine a p-score of ~0.15. Since p > 0.05 there is no strong evidence that Python 3.11 and 3.14 have different energy consumption distributions. When calculating the percentage of pairs supporting a conclusion we see that 61.03% of all possible pairwise comparisons show that Python 3.11 consumes more energy than Python 3.14. This means that in the majority of cases, Python 3.14 is more efficient, but not overwhelmingly so. In terms of common language effect size this is a score of 0.613. 
## Implications
A common misunderstanding when it comes to sustainable software engineering is the idea that improving the execution time of a program reduces the amount of energy used, as this is not necessarily always the case [TODO](https://link.springer.com/chapter/10.1007/978-3-319-09967-5_10). In cases where a program improves efficiency with regards to time by utilizing more power intensive methods, a reduction in time could not have the desired outcome in terms of energy consumption [TODO](https://www.sciencedirect.com/science/article/pii/S1877750313000173). 

With regards to our study, we were interested to know whether the claimed performance increase had a similar improvement on energy consumption or not. When comparing Python 3.14 without tail-call-interp with Python 3.11, there was only little difference in energy consumption. Unfortunately, since the prerelease version of Python 3.14 does not give the possibility of testing with the new interpretation feature, we are unable to determine the energy consumption with this feature enabled. For the current prerelease version, in terms of sustainability, our results would suggest that there is not necessarily a reason to switch at this point in time. 

## Future work 

Although Python 3.14 showed no significant performance or energy efficiency gains over Python 3.11 in our tests, future research should revisit this comparison when the *tail-call-interpreter* becomes functional. With the creation of a replication package, our study ensures that replicating the results on the full version of Python 3.14 with the tail-call-interp feature should be simple when the the time comes.
To identify potential optimization opportunities in Python 3.14, we could also run demanding I/O scenarios and multi-threading executions.

##  Conclusion 
Our study examined the energy consumption and performance differences between Python 3.14 and Python 3.11. We assess if Python 3.14’s allegedly 30% speed improvement can be seen in energy efficiency. Using EnergiBridge, we measured power usage and execution time across computationally intensive operations.
Our results indicate that there is no statistically significant difference in energy consumption or execution time between Python 3.14 (in its default configuration) and Python 3.11. 

Given this, we see no convincing motivation to switch from the more stable and well-supported Python 3.11 to Python 3.14 (at this time). The experimental tail call interpreter, which could provide further optimizations, remains non-functional, limiting Python 3.14’s potential benefits.

